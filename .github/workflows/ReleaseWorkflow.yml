# @file ReleaseWorkflow.yml
#
# A reusable CI workflow that releases all crates in a repository.
#
##
# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: BSD-2-Clause-Patent
##
name: Publish

on:
  workflow_call:
    secrets:
      GH_PAT:
        description: 'The GitHub Personal Access Token to use for authenticating with GitHub'
        required: true
      CRATES_IO_TOKEN:
        description: 'The token to use for authenticating with crates.io'
        required: true

jobs:
  run:
    name: Publish

    runs-on: ubuntu-latest

    permissions:
      contents: write
      actions: read

    steps:
      - name: ✅ Checkout Repository ✅
        uses: actions/checkout@v4

      - name: 🛠️ Download Rust Tools 🛠️
        uses: pop-project/uefi-dxe-core/.github/actions/rust-tool-cache@main

      - name: Add Credentials # Remove once repositories are public
        run: |
          git config --global url."https://${{ secrets.GH_PAT }}@github.com".insteadOf https://github.com
        shell: bash

      - name: Get Current Draft Release
        id: draft_release
        uses: actions/github-script@v7
        with:
          script: |
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            const draftReleaseList = releases.data.filter(release => release.draft);

            if (draftReleaseList.length === 0) {
              core.setFailed("No draft release found. Exiting with error.");
            } else if (draftReleaseList.length > 1) {
              core.setFailed("Multiple draft releases found. Exiting with error.");
            } else {
              const draftRelease = draftReleaseList[0];

              let tag = draftRelease.tag_name;
              if (tag.startsWith('v')) {
                tag = tag.slice(1);
              }
              core.setOutput("id", draftRelease.id);
              core.setOutput("tag", tag);
              console.log(`Draft Release ID: ${draftRelease.id}`);
              console.log(`Draft Release Tag: ${tag}`);
            }

      - name: Install msrustup
        env:
          MSRUSTUP_PAT: ${{ secrets.CRATES_IO_TOKEN }}
        run: |
          # Originally from https://aka.ms/install-msrustup.sh
          # Version 5
          # This script is expected to be copied into any build system that needs to install the internal Rust toolchain, if
          # that system cannot use an ADO pipeline and the Rust installer pipeline task.
          # Updates to this script will be avoided if possible, but if it stops working in your environment, please check the above
          # source location in case of any changes.

          # Downloads msrustup from Azure Artifacts.
          # Requires MSRUSTUP_ACCESS_TOKEN or MSRUSTUP_PAT environment variables to be set with a token.
          # See https://aka.ms/rust for more information.

          command -v uname >/dev/null 2>&1 || { echo >&2 "install-msrustup requires uname to detect host."; exit 1; }
          command -v curl >/dev/null 2>&1 || { echo >&2 "install-msrustup requires curl to download msrustup."; exit 1; }
          command -v jq >/dev/null 2>&1 || { echo >&2 "install-msrustup requires jq to parse Azure Artifact response."; exit 1; }
          command -v unzip >/dev/null 2>&1 || { echo >&2 "install-msrustup requires unzip to unzip msrustup."; exit 1; }

          if [ -z "$MSRUSTUP_ACCESS_TOKEN" ] && [ -z "$MSRUSTUP_PAT" ]; then
              if $(command -v azureauth >/dev/null 2>&1); then
                  MSRUSTUP_ACCESS_TOKEN=$(azureauth ado token)
              elif $(command -v azureauth.exe >/dev/null 2>&1); then
                  MSRUSTUP_ACCESS_TOKEN=$(azureauth.exe ado token)
              else
                  echo "MSRUSTUP_ACCESS_TOKEN or MSRUSTUP_PAT must be set or azureauth must be present."
                  exit 1
              fi
          fi

          if [ -z "$MSRUSTUP_ACCESS_TOKEN" ]; then
              accessMethod=pat
          else
              accessMethod=token
          fi

          if [ -z "$MSRUSTUP_FEED_URL" ]; then
              MSRUSTUP_FEED_URL='https://mscodehub.pkgs.visualstudio.com/Rust/_packaging/Rust%40Release/nuget/v3/index.json'
          fi

          # Now that we've tested for missing required variables, treat unset variables as an error.
          set -eu

          function cleanup() {
            rm -f msrustup.zip
          }
          trap cleanup EXIT

          function do_curl() {
              if [ "$accessMethod" = "token" ]; then
                  curl -sSfLH "Authorization: Bearer $MSRUSTUP_ACCESS_TOKEN" --retry 5 $@
              else
                  curl -sSfLu :$MSRUSTUP_PAT --retry 5 $@
              fi
          }

          target_arch=''
          target_rest=''

          # We intentionally use the msvc host toolchain for variations of Windows (CYGWIN, MINGW, etc)
          # since no other Windows host toolchain is supported.
          unameOut="$(uname -s)"
          case "${unameOut}" in
              Linux*)     target_rest="-unknown-linux-gnu";;
              Darwin*)    target_rest="-apple-darwin";;
              CYGWIN*)    target_rest="-pc-windows-msvc";;
              MINGW*)     target_rest="-pc-windows-msvc";;
              MSYS_NT*)   target_rest="-pc-windows-msvc";;
              *)          { echo "host environment could not be determined: ${unameOut}"; exit 1; }
          esac

          # Detect x86_64 or aarch64 (Apple devices report as "arm64", Linux as "aarch64" usually).
          arch="$(uname -m)"
          case "${arch}" in
              x86_64*)   target_arch="x86_64";;
              aarch64*)  target_arch="aarch64";;
              arm64*)    target_arch="aarch64";;
              *)         { echo "unknown host arch: ${arch}"; exit 1; }
          esac

          echo "Host is ${target_arch}${target_rest}"
          package="rust.msrustup-${target_arch}${target_rest}"

          response=$(do_curl $MSRUSTUP_FEED_URL)
          base=$(echo $response | jq -r '.resources[] | select(."@type"=="PackageBaseAddress/3.0.0") | .["@id"]')
          version=$(do_curl "$base$package/index.json" | jq -r '.versions[0]')
          latest="${base}${package}/$version/$package.$version.nupkg"

          echo "Downloading msrustup $version from $latest"
          do_curl "$latest" -o msrustup.zip

          if [ "$target_rest" = "-pc-windows-msvc" ]; then
              unzip -jqo msrustup.zip tools/msrustup.exe
          else
              unzip -jqo msrustup.zip tools/msrustup
              chmod +x msrustup
          fi

          export PATH="$PATH:$GITHUB_WORKSPACE"
          source ~/.bashrc

      - name: Login to Crates.io
        run: cargo login ${{ secrets.CRATES_IO_TOKEN }} --registry UefiRust

      - name: Cargo Release Dry Run
        run: cargo release ${{ steps.draft_release.outputs.tag }} --workspace
        env:
          RUSTC_BOOTSTRAP: 1
          CARGO_REGISTRIES_UEFIRUST_TOKEN: ${{ secrets.CRATES_IO_TOKEN }}

      - name: Update git credentials
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Cargo Release
        run: cargo release ${{ steps.draft_release.outputs.tag }} -x --no-tag --no-confirm --workspace
        env:
          RUSTC_BOOTSTRAP: 1
          CARGO_REGISTRIES_UEFIRUST_TOKEN: ${{ secrets.CRATES_IO_TOKEN }}

      - name: Wait for Release Draft Updater
        uses: actions/github-script@v7
        with:
          script: |
            const workflowId = "update-release-draft.yml";
            const ref = "main";
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Try for 10 minutes. It should only take a few seconds
            let maxAttempts = 40;
            let attempt = 0;
            let completed = false

            while (attempt < maxAttempts && !completed) {
              await new Promise(resolve => setTimeout(resolve, 15000));
              const runs = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: workflowId,
                branch: ref,
                event: 'push',
                status: 'in_progress',
              });

              if (runs.data.workflow_runs.length === 0) {
                completed = true;
              } else {
                attempt++;
              }
            }

            if (!completed) {
              core.setFailed("Release Drafter did not complete in time. Please perform the release manually.");
            }

      - name: Publish Release
        uses: actions/github-script@v7
        with:
          script: |
            const releaseId = ${{ steps.draft_release.outputs.id }};

            const response = await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              draft: false,
            });

            if (response.status !== 200) {
              core.setFailed(`Failed to publish release. Exiting with error.`);
            }
