# RFC: Fixed PCD and `Config<T>` Interop

*This RFC is in a draft state and will be updated with additional details. Prototyping is set to begin next week (week of 9/15).*

This RFC proposes a translation mechanism to allow fixed PCDs to be converted into component-friendly `Config<T>`s without directly introducing the concept of PCDs into Patina. The conversion mechanism will in the form of an EDK2 build system plugin and a Patina component connected through a crate which defines a shared macro. Of note:
- The proposed mechanism will not require custom Cargo build support, and will not require Patina re-compilation when configuration values are changed.
- The proposed mechanism will not require Patina re-compilation when configuration values are changed.
- Patina will be unaware of EDK2 build system and PCD name/namespace specifics
- Platform C-code (apart from what is autogenerated), will be unaware of Patina configuration structures

At a high level, the basic flow for using PCD-defined values in Patina components will be as follows:

1. Configuration structs can be marked with `#[derive(ExternallyConfigurable)]`, indicating they can be configured via an external build system.
2. On the EDK2-side, minimal per-Component `.inf` files will define mappings between marked configuration structure fields and fixed PCDs.

    ```yaml
    # MyComponent.inf

    [Defines]
      INF_VERSION                    = 0x00010005
      BASE_NAME                      = MyComponent
      MODULE_TYPE                    = PATINA_COMPONENT

    [ComponentConfigurations]
        MyConfigStruct.Field1 = PcdNameSpace.PcdName
    ```

3. Using a top-level `Cargo.lock`, a Rust EDK2 build system extension will locate all marked structures within Patina-related source files and create instances of these structs populated with the values of the mapped PCDs.
4. The build system extension will add these to a HOB via an auto-generated PEIM.
5. A Patina `ExternalConfiguration` component will process this HOB and generate `Config<T>`s as appropriate.

More detailed information on each step can be found in the "Code Design" section of this document.

## Change Log

This text can be modified over time. Add a change log entry for every change made to the RFC.

- 2025-09-08: Initial RFC created.

## Motivation

The ability to statically configure Components is vital for facilitating Component-sharing between platforms that require divergent behavior. Furthermore, allowing this configuration to be global to not just Patina but to the build system Patina is incorporated within ensures configuration parity between Patina and non-Patina UEFI components. While, as present, these configurations could be manually transfered, this process is error prone, especially as configuration changes may occur in EDK2 within Git submodules.

EDK2 largely achieves static configuration through fixed PCDs that have their values compiled into the C-based modules that request them via declarations in `.inf`, `.dsc`, and `.dec` files. Fixed PCDs meet the challenge of configuring modules for a potentially wide array of platforms well by providing a hierarchical model where PCDs can be scoped and overwritten as needed. As directly adding support for fixed PCDs into the cargo build system would be non-idiomatic for Rust and how Crate repositories generally work (see "Alternatives") section, providing a level of indirection by which the EDK2 build system can publish Rust-compatible configurations based on PCD values provides a middle-ground in which Patina requires no knowledge of the EDK2 build system (outside of the Rust build plugin) or of PCD-specifics. 

## Technology Background

Fixed PCDs allow the EDK2 build system to compile constant values into UEFI modules. These values can be of types `u8`, `u16`, `u32`, `u64`, `bool`, or byte-arrays. Information on fixed PCDs and PCDs in general can be found [here](https://github.com/tianocore/tianocore.github.io/wiki/PCD) and in the [EDK2 Build Specification](https://tianocore-docs.github.io/edk2-BuildSpecification/release-1.28/).

In order to read and populate structs defined in crates containing configuration structures, cross-crate reflection will be required. While the exact approach, this can be achieved with a combination of the [`cargo rustdoc --`](https://dirname.github.io/rust-std-doc/cargo/commands/cargo-rustdoc.html) command and by either populating a byte-compatible `[u8; N]` or by compiling the EDK2 build tool at build-time, using [procedural macros](https://doc.rust-lang.org/reference/procedural-macros.html) and the [syn](https://docs.rs/syn/latest/syn/) crate as needed.

## Goals

The goal of this RFC is to create a translation layer that allows fixed PCDs to be used by Patina Components. This layer should:
1. Be automatic and minimize potential for mismatched or incomplete configuration by emitting build-time errors.
2. Be ergonomic and require minimal user interaction.
3. Be EDK2-unaware from Patina's perspective.
    - The interaction between the EDK2 build tool and Patina should be standardized and build-system agnostic, potentially allowing seamless integration with other build systems as well
4. Be efficient and avoid unnecessary duplication of large shared configuration parameters.
5. Provide a mechanism for evaluating whether a given configuration state is valid and should be installed as a `Config<T>`.

## Requirements

1. Configuration fields must be effectively read-only.
2. Configuration must not require a modified Rust build system and should be compatible with Cargo registries.
3. Modifying configuration values must not require rebuilding Rust crates.
4. Modifying a fixed PCD's value in EDK2 must be sufficient to change the corresponding value within the Rust configuration struct.

## Unresolved Questions

This section will be updated as questions arise and are resolved during the prototyping phase.

### 1. Will the component model need to be updated to allow per-component overrides?

PCD overrides are a core functionality heavily worth considering. Currently, component `Config<T>`s are applicable to all components. To allow seamless per-component overrides, the Component model may need to be updated to allow `Config<T>` instances to be earmarked for specific components. Whether this is a step worth taking and the mechanism by which this would be done are both open questions.

### 2. What limitations will need to be placed on structures marked as `#[derive(ExternallyConfigurable)]`?

To ensure portability between the Rust version used to compile Patina and the version used to compile the EDK2 build tool, structures passed to Patina through the HOB will need to be `#[repr(C)]` and `#[pack(1)]`. Whether these limitations can be confined to internal, procedurally generated, structures, or must apply to all structures marked with `#[derive(ExternallyConfigurable)]` is to be determined.

Additional limitations will also likely be placed on the marked data structures to ensure PCD types can only be mapped to their defined types (or to structs that implement a deserialization trait such as `zerocopy::FromBytes`) in the case of `VOID*` byte-array fixed PCDs.

### 3. How will the Patina ExternalConfiguration component determine whether a configuration structure is "enabled" and should be installed as a `Config<T>`?

This could be achieved a few ways. The simplest would be to add an "enabled" boolean configuration field to each marked struct which the ExternalConfiguration component would check. Alternatively, marked structures would implement a `ConditionallyEnabled` trait which would define a struct-specific function for determining whether a `Config<T>` should be installed.

### 4. Where should PCD mappings for configuration structures shared by multiple crates be located?

There are a couple of options here:
1. Store metadata in the HOB that would mandate `Config<T>` for `ExternallyConfigurable` structs can only be installed on components that define the config in their `.inf`.
2. Allow non-component-specific PCD-mapping `.inf`s.

## Prior Art (Existing PI C Implementation)

Corresponding EDK2 C behavior is outlined in the fixed PCD sections of the [EDK2 Build Specification](https://tianocore-docs.github.io/edk2-BuildSpecification/release-1.28/).

## Alternatives

### Alternative 1: Manual Definition in Code Containing Invocation of Patina
- PCD configuration values can be manually copied from the EDK2 build system to Rust code containing the platform's invocation of Patina DXE Core.
- Issues
    - Requires maintaining parity between EDK2 and Rust code manually, which is manual and error prone.

### Alternative 2: Single PEIM Installing a HOB
- Instead of using a build system tool, a single PEIM can install the HOB which it populates from PCDs it requires through its own `.inf`.
- Issues
    - The potential for struct-layout mismatches would require sharing a set of header files which cover all Patina configuration structures.
    - All PCDs would be in the PEIM scope.
    - There is no good way to provide per-component PCD overrides.
    - Layout errors and struct field mismatches wouldn't be easily caught.

### Alternative 3: Central + Per-Component (or Per-`Config<T>`) PEIMs
- Instead of using a build system tool, one central PEIM and per-component PEIMs which would install split HOBs.
- Issues
    - The potential for struct-layout mismatches would require sharing a set of header files which cover all Patina configuration structures.
    - All PCDs would still be in the PEIM scope.
    - Layout errors and struct field mismatches wouldn't be easily caught.
    - Extremely unergonomic, and hard to keep track of.

### Alternative 4: Consolidate All Required PCDs into a "PCD Store" HOB
- Rather than trying to generate Rust-compatible structs from the EDK2 build system, publish all required PCDs in a consolidated HOB which a Patina-side component would split apart into `Config<T>`s
- Fields in configuration structs would be annotated with the PCD namespace and GUID they are associated with: `#[derive(FromPCD(PcdNameSpace, PcdName))]`
- Issues
    - Deserialization to Rust-compatible structures (and the errors which may arise) would be runtime, not build-time
    - Patina components would need to be aware of the EDK2 build system, and would need to keep track of PCD names and namespaces 

## Code Design

This RFC will be prototyped in the coming weeks. More detailed information on code design will be provided once a prototype is built.

This RFC will consist of three parts: a macro crate, an EDK2 build system plugin, and a Patina component.

### 1. Shared `ExternallyConfigurable` Macro Crate
The macro crate will be responsible for defining the `ExternallyConfigurable` procedural macro.

This macro will serve two purposes on the structs it's derived upon:
1. Installing a marker trait
2. Ensuring the struct is laid out in such a way that is safe to serialize and portable across Rust compiler versions

### 2. EDK2 Build System Plugin

The EDK2 build system plugin, which will be written with both Rust and Python components, will be responsible for the following aspects of this RFC:
1. Gathering mappings of configuration struct fields to named PCDs
2. Retrieving the value of the named PCDs
3. Using some form of reflection to scan all relevant Crates in the EDK2 project's top-level Patina `cargo.lock` for configuration structs marked with `#[derive(ExternallyConfigurable)]`, then gather metadata on those structs
    - Specifically, it'd be looking for all Crates that take a dependency on the macro crate
4. Building versions of those structs with fields populated by the gathered PCD values
5. (TBD) Run deserialization functions on non-trivial data types to catch errors early
5. Serializing those structs in a Rust-portable way
6. Generating and injecting a PEIM that installs the serialized structs as a HOB

### 3. Patina `ExternalConfiguration` Component
The Patina component would be responsible for the following aspects of this RFC:
1. Unpacking the configuration structs from the HOB
2. Running a check to see if the configuration struct should be considered "enabled" and installed as a `Config<T>`
3. Installing enabled configuration structs as `Config<T>`s



## Guide-Level Explanation

This RFC will be prototyped in the coming weeks. A guide-level explanation will be provided once additional details have been finalized.
