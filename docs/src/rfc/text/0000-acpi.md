# RFC: `ACPI`

This RFC proposes a Rust-based interface for ACPI table management providing the functionality described in the
`EFI_ACPI_TABLE_PROTOCOL` and `EFI_ACPI_SDT_PROTOCOL` services defined respectively in the UEFI Specification and PI Specification.
It introduces an AcpiProvider trait to manage installation, uninstallation, and retrieval of ACPI tables,
encapsulating both the ACPI Table and SDT protocols behind a safe, idiomatic Rust API.
The goal is to maintain compatibility with the UEFI specification
while improving memory safety and simplifying integration for components.

## Change Log

- 2025-04-17: Initial RFC created.
- 2025-04-22: Add iteration for `AcpiProvider`. Add `RegisterNotify` functionality.
- 2025-04-23: Add `From`/`Into` between specific ACPI tables and the general `AcpiTable` type.
Remove `Component` and `Config` suffixes from types.
- 2025-04-24: Add example for initializng a MCFG table with the new interface.

## Motivation

The Advanced Configuration and Power Interface (ACPI)
provides information about device topology, configuration, and power management.
This RFC proposes a pure Rust interface for existing ACPI capabilities, replacing the C-based implementations
while producing protocols that align with the UEFI specification. This provides a simpler, safer Rust-based interface
while maintaining required ACPI functionality.

### Scope

The `AcpiProvider` service implements equivalent functionality for the following protocols:

- `EFI_ACPI_TABLE_PROTOCOL`
  - `InstallAcpiTable`
  - `UninstallAcpiTable`
- `EFI_ACPI_SDT_PROTOCOL`
  - `GetAcpiTable`
  - `RegisterNotify`

## Technology Background

### ACPI

ACPI within UEFI provides a standardized interface for firmware
to convey hardware configuration and power management information to the operating system.
This information is organized into a set of structured tables.

For more information on the format and arrangement of these tables,
see the UEFI specification on the [ACPI Software Programming Model](https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/05_ACPI_Software_Programming_Model/ACPI_Software_Programming_Model.html#acpi-software-programming-model).

### Protocols

The UEFI Forum Specifications expose two primary protocols for interacting with ACPI data:

- The ACPI Table Protocol installs and uninstalls individual ACPI tables.
  - [EFI_ACPI_TABLE_PROTOCOL](https://uefi.org/specs/UEFI/2.10/20_Protocols_ACPI_Protocols.html#efi-acpi-table-protocol)
- The ACPI SDT (System Description Table) Protocol provides access to and enables traversal of the full ACPI table hierarchy.
  - [EFI_ACPI_SDT_PROTOCOL](https://uefi.org/specs/PI/1.8A/V5_ACPI_System_Desc_Table_Protocol.html)

## Goals

Create a idiomatic Rust API for both ACPI-related protocols (*see [Motivation - Scope](#scope)*).

## Requirements

1. The API should provide all necessary ACPI functionality as a service to components
2. The API should utilize Rust best practices, particularly memory safety and error handling
3. The ACPI should produce protocols equivalent to the current C implementations, preserving existing C functionality

## Unresolved Questions

- Which parts of the SDT protocol are necessary to re-implement in Rust?
  - In platform code, `GetAcpiTable` is the only one currently used,
  so the current RFC proposes to only re-implement this part of the protocol.
- Is there a way to re-write the Rust interface without global statics,
while preserving compatibility with the existing C implementation?
- Is there value in exposing the ACPI table protocol and ACPI SDT protocol as separate services?

## Prior Art (Existing PI C Implementation)

The Rust-based ACPI implementation follows the ACPI Table protocol and ACPI SDT protocol
as described in the UEFI specification. *See [Protocols](#protocols) for more information.*

This RFC chooses to omit most of the ACPI SDT protocol,
implementing only `GetAcpiTable` based on investigation into its practical usage in real platform code.

In C, `EFI_ACPI_TABLE_INSTANCE` provides metadata relating to ACPI tables,
and `EFI_ACPI_SDT_HEADER` represents information about a specific table.
These are roughly replicated by the Rust structs described in [Acpi Tables](#acpi-tables).

## Rust Code Design

### ACPI Provider Service

Integrated functionality for installing, uninstalling, and getting a specific ACPI table
will be provided through the `AcpiProvider` service.

```rust
type AcpiNotifyFn = fn(&AcpiTable, AcpiVersion, TableKey) -> Result<(), AcpiTableError>;

pub trait AcpiProvider {
    type Iter: Iterator<Item = AcpiTable>;

    fn install_acpi_table(&self, acpi_table: &AcpiTable) -> Result<TableKey, AcpiTableError>;
    fn uninstall_acpi_table(&self, table_key: TableKey) -> Result<(), AcpiTableError>;
    fn get_acpi_table(&self, index: usize) -> Result<&AcpiTable, AcpiTableError>;
    fn register_notify(&self, should_register: bool, notify_fn: AcpiNotifyFn) -> Result<(), AcpiTableError>;

    fn iter(&self) -> Self::Iter;
}
```

The division between ACPI table protocol and ACPI SDT protocol is represented by two traits
`AcpiTableManager` and `AcpiSdtManager`; which also produce the necessary protocols.
However, these traits are not exposed to consumers of the ACPI service for simplicity.

### ACPI Tables

All common fields relating to a specific ACPI table are stored in the `AcpiTableStruct`, defined as follows:

```rust
struct AcpiTable {
    signature: u32,
    length: u32,
    revision: u8,
    checksum: u8,
    oem_id: [u8; 6],
    oem_table_id: [u8; 8],
    oem_revision: u32,
    creator_id: u32,
    creator_revision: u32,
    table_key: TableKey, // type alias for u32
    versions: AcpiVersion, // bitflag
    data: Vec<u8>, // variable-length data and entries
}
```

#### Specialized ACPI Tables

Specific ACPI tables (like the FADT, MADT, etc) will implement `TryFrom<AcpiTable>`
to safely convert between the general `AcpiTable` struct and specific table formats.

An example for the MCFG is in [Guide-Level Explanation](#guide-level-explanation).

#### ACPI Support

A global `AcpiTableProtocolSupport` struct provides metadata, such as pointers to the root ACPI tables.

```rust
#[repr(C, packed)]
#[derive(Debug)]
struct EfiAcpiTableInstance {
    signature: usize,
    rsdp1: Acpi10RSDP,
    // ... 
    // for brevity, the rest of the table pointers are omitted
    // ...
    table_list: Vec<AcpiTable>,
    number_of_table_entries1: usize,
    number_of_table_entries3: usize,
    current_handle: usize,
    acpi_table_protocol: AcpiTableProtocol,
    acpi_sdt_protocol: AcpiSdtProtocol
}

```

### ACPI Component

A single component `AcpiInit` initializes the root ACPI tables, registers the ACPI provider service,
and installs the table and SDT protocols.

## Guide-Level Explanation

All interaction with ACPI tables will be mediated by the `AcpiProvider` trait interface.
As stated before, consumers will access this service as follows:

```rust
pub fn component (acpi_provider: Service<dyn AcpiProvider>) -> Result<()> {
    acpi_provider.install_acpi_table( ... );
    // ...
    for table in acpi_provider.iter() {
      // ...
    }
}
```

When installing a table with `install_acpi_table`, a unique identifier `TableKey` will be returned.
This unique handle can later be used in `uninstall_acpi_table`.

Upon calling `install_acpi_table`, any functions registered with `register_notify` will be called.

`get_acpi_table` finds a specific ACPI table by index,
either in the firmware-provided tables or custom tables installed by `install_acpi_table`.
Alternatively, `AcpiProvider` also allows access to all tables through iteration.

### MCFG Example

Below, we provide an example of utilizing the `AcpiProvider` service to initialize and install a MCFG table,
including all necessary configs, services, and components.

The code roughly follows the structure presented in the below diagram:
![image](0000-acpi-services/mcfg_example.png)

```rust
struct McfgEntry {
    base_address: u64,
    pci_segment_group: u16,
    start_bus: u8,
    end_bus: u8,
    reserved: u32,
}

struct AcpiMcfg {
  reserved: u64,
  entries: Vec<McfgEntry>, // variable-length list of regions
}

struct AcpiMcfgInit {
  segment_count: usize,
  oem_revision: u32,
  table_base: u64,
}

impl TryFrom<AcpiTable> for AcpiMcfg {
  fn try_from(table: &AcpiTable) {
      let reserved = u64::from_le_bytes(table.data[0..8].try_into().unwrap());

      // ... additional parsing logic ...

      Ok(AcpiMcfg { reserved, entries })
  }
}

fn install_mcfg(self, config: ConfigMut<AcpiMcfgInit>, acpi_provider: Service<dyn AcpiProvider>) -> uefi_sdk::error::Result<()> {
  let segment_info = get_pci_segment_info(config.segment_count);
  let mcfg_table = AcpiTable::default();
  
  mcfg_table.length = config.segment_count;
  mcfg_table.data = read_bytes(config.table_base, mcfg_table.length)
  // ... fill in rest of mcfg fields ...

  acpi_provider.install_acpi_table(&mcfg_table);

  let mcfg_table = mcfg_table.try_into().unwrap();
  // ... do more checks and parsing ...
}

fn acpi_init() {
  let core_acpi_provider = CoreAcpiProvider::default();
  core_acpi_provider.register(); // brings `AcpiProvider` service up
  // ... install protocols, etc ...
}

fn _start() {
  let oem_revision = /* some platform value */
  let segment_count = /* some platform value */
  let table_base = /* get from RSDP */

  // ...

  Core::default()
        // ...
        .with_component(acpi_init)
        .with_config(AcpiMcfgInit { segment_count, oem_revision, table_base })
        .with_component(install_mcfg)
        // ...
}
```
